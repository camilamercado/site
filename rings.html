<!DOCTYPE html>
<meta charset="utf-8">

<head>
	
	<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
	<script src="http://d3js.org/d3.v3.min.js"></script>

	<style type="text/css">

	.slice path {
    stroke: #fff;
    stroke-width: 1px;
	}

	.textTop {
	    font-family: 'Segoe UI';
	    font-size: 12pt;
	    fill: #bbb;
	}

	.textBottom {
	    fill: #444;
	    font-family: 'Segoe UI';
	    font-weight: bold;
	    font-size: 18pt;
	}

	.top {
	    border: 1px solid #bbb;
	    color: #777;
	    font-family: 'Segoe UI';
	    padding: 5px;
	    text-decoration: none;
	}

	.top:hover {
	    border: 1px solid #555;
	    color: #333;
	}

	</style>
</head>

<body>

	<div id="holder">

		<div id="threshold"></div>
	</div>

	<ul class="testers">
		<li><a href="#">1</a></li>
		<li><a href="#">2</a></li>
	</ul>


<script>


	var arcGenerator = {
		radius: 100,
		oldData: "",
		init: function(data){
			var clone = jQuery.extend(true, {}, data);
			
			var preparedData = this.setData(clone);			
			this.oldData = preparedData;
			this.setup(preparedData);			
		},
		update: function(data){
			var clone = jQuery.extend(true, {}, data);
			
			var preparedData = this.setData(clone);
		
			this.animate(preparedData);			
			this.oldData = preparedData;
		},
		animate: function(data){
			var that = this;
			
			var chart = d3.select(".arcchart");
			that.generateArcs(chart, data);
		},	
		setData: function(data){
			var diameter = 2 * Math.PI * this.radius;			
			var localData = new Array();
			
			var segmentValueSum = 0;
			$.each(data[0].segments, function( ri, va) {
				segmentValueSum+= va.value;
			});
				
			$.each(data[0].segments, function(ri, value) {
								
				var segmentValue = value.value;
				
				var fraction = segmentValue/segmentValueSum;
				
				var arcBatchLength = fraction*4*Math.PI;
				var arcPartition = arcBatchLength;		
				
				var startAngle = Math.PI/2;			
	            var endAngle = startAngle + arcPartition; 
                
				data[0].segments[ri]["startAngle"] = startAngle;
				data[0].segments[ri]["endAngle"] = endAngle;
				data[0].segments[ri]["index"] = ri;
			});
				
			localData.push(data[0].segments);
						
			return localData[0];		
		},
        textOffset: 10,
		generateArcs: function(chart, data){
			
			var that = this;
			
			//append previous value to it.			
			$.each(data, function(index, value) {
				if(that.oldData[index] != undefined){
					data[index]["previousEndAngle"] = that.oldData[index].endAngle;
				}
				else{
					data[index]["previousEndAngle"] = 0;
				}
			});		
	
			var arcpaths = chart.selectAll("path")
					.data(data);
	
				arcpaths.enter().append("svg:path")
					.attr("class", function(d, i){
						return d.machineType;
					})	
					.style("fill", function(d, i){
						return d.color;
					})
					.transition()
					.ease("elastic")
					.duration(750)
					.attrTween("d", arcTween);				 
				
				arcpaths.transition()
					.ease("elastic")
					.style("fill", function(d, i){
						return d.color;
					})
					.duration(750)
					.attrTween("d",arcTween);
				 
				arcpaths.exit().transition()
					.ease("bounce")
					.duration(750)
					.attrTween("d", arcTween)
					.remove();
            
            

   
                  var value_group = chart.append("svg:g")
                                    .attr("class", "value_group")
                                    .attr("transform", "translate(0,0)");   
            
            
            var reversedata = data.reverse();
            var counts = data.length;
            
            //draw labels						
            valueLabels = value_group.selectAll("text.value").data(reversedata)
            valueLabels.enter().append("svg:text")
            .attr("class", "value")
            .attr("transform", function(d) {
                var rings = counts;
                
                return "translate("+(that.radius+55)/rings+", 0)";
            })
             .attr("dx", function(d, i){
                return 19*i;            })
            .attr("dy", function(d, i){
                return -5;
            })
            .attr("text-anchor", function(d){
                return "start";
            }).text(function(d){
                return d.value;
            });
            
            valueLabels.transition().duration(300).attrTween("d", arcTween)
            valueLabels.exit().remove();          
            
            
            
           that.buildLegend(chart, data); 
                                

			function arcTween(b) {
			
				var prev = JSON.parse(JSON.stringify(b));
				prev.endAngle = b.previousEndAngle;
				var i = d3.interpolate(prev, b);

				return function(t) {
					return that.getArc()(i(t));
				};
			}			
		},
        buildLegend: function(chart, data){

                  var label_group = chart.append("svg:g")
                          .attr("class", "label_group")
                          .attr("transform", "translate(130,-100)");   
                            
                     
   
                    //draw labels						
                    labels = label_group.selectAll("text.labels").data(data.reverse());
                    
                    labels.enter().append("svg:text")
                        .attr("class", "labels")
                        .attr("dy", function(d, i){
                            return 19*i
                        })
                        .attr("text-anchor", function(d){
                            return "start";
                        })
                        .text(function(d){
                            return d.label;
                        });  
            
                                    
                   labels.exit().remove();
            
            var legend_group = chart.append("g")
						.attr("class", "legend_group")
						.attr("transform", "translate(5,-116)");	
            
             legend = legend_group.selectAll("rect").data(data);
            
             legend.enter().append("svg:rect")
						  .attr("x", 100)
              .attr("y", function(d, i){
                            return 19*i
                        })
						  .attr("width", 18)
						  .attr("height", 18)
						  .style("fill", function(d){
                            return d.color;
                            });  
            legend.exit().remove();
        },
		setup: function(data){		
			var chart = d3.select("#threshold").append("svg:svg")
					.attr("class", "chart")
					.attr("width", 420)
					.attr("height", 420)
						.append("svg:g")
						.attr("class", "arcchart")
						.attr("transform", "translate(200,200)");

			this.generateArcs(chart, data);		
		},
        getRadiusRing: function(i){
            return this.radius-(i*20);				
		},
		getArc: function(){
			var that = this;
			
			var thickness = 15;
			
			var arc = d3.svg.arc()
					.innerRadius(function(d){
						return that.getRadiusRing(d.index);						
					})
					.outerRadius(function(d){
						return that.getRadiusRing(d.index)+thickness;	
					})
					.startAngle(function(d, i){
						return d.startAngle;
					})
					.endAngle(function(d, i){
						return d.endAngle;
					});		
			return arc;
		}
	}
    
    
    
	$(document).ready(function() {

		var dataCharts = [
				{
					"data": [
						{
							"segments": [
								{
                                    "label": "Turkey",
                                    "value": 25,
									"color": "red"
								},
								{
									"label": "United States",
                                    "value": 40,
									"color": "blue"							
								},
								{
									"label": "Switzerland",
                                    "value": 60,
									"color": "green"							
								},
								{
									"label": "Iceland",
                                    "value": 80,
									"color": "gold"
								}							
							]
						}
					]
				},
				{
					"data": [
						{
							"segments": [
								{
									"label": "Peanut Butter",
                                    "value": 50,
									"color": "red"
								},
								{
									"label": "Tea",
                                    "value": 67,
									"color": "orange"							
								},
								{
									"label": "Cheese",
                                    "value": 10,
									"color": "green"							
								}						
							]
						}
					]
				}				
			];
			
			var clone = jQuery.extend(true, {}, dataCharts);
			
			arcGenerator.init(clone[0].data);
			
			$(".testers a").on( "click", function(e) {
				e.preventDefault();

				var clone = jQuery.extend(true, {}, dataCharts);

				var pos = $(this).parent("li").index();
				arcGenerator.update(clone[pos].data);			
			});
			
	});

</script>





 // var circleRadii = [50, 70, 90, 110, 130, 150];
 //  τ = 2 * Math.PI; 

 // var svgContainer = d3.select("body").append("svg")
 //               .attr("width", 800)
 //               .attr("class", "butt")
 //               .attr("height", 500);

 // var circles = svgContainer.selectAll("circle")
 //               .data(circleRadii)
 //               .enter()
 //               .append("circle")

 // var arc = d3.svg.arc()
 //            .innerRadius(0)
 //            .outerRadius(circleRadii[4])
 //            .startAngle(0);

 // var background = svg.append("path")
 //                    .datum({endAngle: τ})
 //                    .style("fill", "#ddd")
 //                    .attr("class", "background")
 //                    .attr("d", arc);

 // var foreground = svg.append("path")
 //                    .datum({endAngle: .50 * τ})
 //                    .style("fill", "#999")
 //                    .attr("class", "foreground")
 //                    .attr("d", arc);


 // var arc2 = d3.svg.arc()
 //            .innerRadius(0)
 //            .outerRadius(circleRadii[0])
 //            .startAngle(0);

 // var background2 = svg.append("path")
 //                    .datum({endAngle: τ})
 //                    .style("fill", "lavender")
 //                    .attr("class", "background")
 //                    .attr("d", arc2);

 // var foreground2 = svg.append("path")
 //                    .datum({endAngle: .50 * τ})
 //                    .style("fill", "mint")
 //                    .attr("class", "foreground")
 //                    .attr("d", arc2);                    


 // var circleAttributes = circles.append("path")
 //               .attr("cx", 250)
 //               .attr("cy", 150)
 //               .attr("r", function (d) { return d; })
               
 //               .style("fill", function(d) {
 //                 var returnColor;
 //                 if (d === 50)         { returnColor = "white";
 //                 } else if (d === 70)  { returnColor = "black";
 //                 } else if (d === 90)  { returnColor = "white"; 
 //                 } else if (d === 110) { returnColor = "black"; 
 //                 } else if (d === 130) { returnColor = "white"; 
 //                 } else if (d === 150) { returnColor = "black";}
 //                 return returnColor;


 //               });


 
// Add the background arc, from 0 to 100% (τ).


// Add the foreground arc in orange, currently showing 12.7%.


// Every so often, start a transition to a new random angle. Use transition.call
// (identical to selection.call) so that we can encapsulate the logic for
// tweening the arc in a separate function below.
// setInterval(function() {
//   foreground.transition()
//       .duration(750)
//       .call(arcTween, Math.random() * τ);
// }, 1500);

// Creates a tween on the specified transition's "d" attribute, transitioning
// any selected arcs from their current angle to the specified new angle.
// function arcTween(transition, newAngle) {

//   // The function passed to attrTween is invoked for each selected element when
//   // the transition starts, and for each element returns the interpolator to use
//   // over the course of transition. This function is thus responsible for
//   // determining the starting angle of the transition (which is pulled from the
//   // element's bound datum, d.endAngle), and the ending angle (simply the
//   // newAngle argument to the enclosing function).
//   transition.attrTween("d", function(d) {

//     // To interpolate between the two angles, we use the default d3.interpolate.
//     // (Internally, this maps to d3.interpolateNumber, since both of the
//     // arguments to d3.interpolate are numbers.) The returned function takes a
//     // single argument t and returns a number between the starting angle and the
//     // ending angle. When t = 0, it returns d.endAngle; when t = 1, it returns
//     // newAngle; and for 0 < t < 1 it returns an angle in-between.
//     var interpolate = d3.interpolate(d.endAngle, newAngle);

//     // The return value of the attrTween is also a function: the function that
//     // we want to run for each tick of the transition. Because we used
//     // attrTween("d"), the return value of this last function will be set to the
//     // "d" attribute at every tick. (It's also possible to use transition.tween
//     // to run arbitrary code for every tick, say if you want to set multiple
//     // attributes from a single function.) The argument t ranges from 0, at the
//     // start of the transition, to 1, at the end.
//     return function(t) {

//       // Calculate the current arc angle based on the transition time, t. Since
//       // the t for the transition and the t for the interpolate both range from
//       // 0 to 1, we can pass t directly to the interpolator.
//       //
//       // Note that the interpolated angle is written into the element's bound
//       // data object! This is important: it means that if the transition were
//       // interrupted, the data bound to the element would still be consistent
//       // with its appearance. Whenever we start a new arc transition, the
//       // correct starting angle can be inferred from the data.
//       d.endAngle = interpolate(t);

//       // Lastly, compute the arc path given the updated data! In effect, this
//       // transition uses data-space interpolation: the data is interpolated
//       // (that is, the end angle) rather than the path string itself.
//       // Interpolating the angles in polar coordinates, rather than the raw path
//       // string, produces valid intermediate arcs during the transition.
//       return arc(d);
//     };
//   });
// }

